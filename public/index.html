<!DOCTYPE html>
<html lang="en" ng-app="app">
<head>
    <meta charset="UTF-8">
    <title>Sender</title>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

</head>
<body ng-controller="mainController">

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">COMP 6905 Assignment 3</a>
        </div>
    </div>
</nav>

<!-- Main jumbotron for a primary marketing message or call to action -->
<div class="panel" style="margin-top: 10%">

    <div class="container">
        <h2>Sender</h2>
        <h3>Implementation</h3>
        <p>
            The sender was implemented as a simple node js application. This application exposes a simple rest api /start, /stop and /count. The /count route returns a JSON object which details the current number of concurrent jobs, total sent request and total completed sent. From our tests a single sender running on an A1 virtual machine in azure can send x messages per second to service bus queue. Thus to achieve the required rate of Y messages per hour (i.e., Y/3600 message per second) we required at least Z virtual machines senders. //Talk about how to activate the sender either manually through the rest api or via the controller webpage. //Talk about how the sender auto generates the request details. TransationId is a count, the remaining values are random string from a pre-defined arrays
        </p>
        <h3>Error Rate</h3>
        <p>
            To simulate the error rate we reserved the transaction name “Error” to simulate errors. If such a message is received, it is logged in an azure table. These error messages can be generated at a specific rate by setting the values of the A and B variables in the sender.
            Messages are read from the service bus queue in two stages. The first stage, retrieves a message from the service bus queue by performing a peek operation. This returns the next available message to the receiver, but does not remove the message from the queue. Instead the message is locked so it becomes invisible to all other receivers. The second stage, deletes the message from the service bus queue after the receiver has finished processing it. Although this performs two operations, every message is guaranteed to be processed at least once. In the event of a failure at the receiver, the delete operation will not be completed. If a message is locked for longer than the pre-defined lock duration (the default value is 30s), the the service bus queue will unlock it. This makes the message available to other receivers. Thus, for every message, unless a delete operation is completed the message will remain on the queue until a receiver processes it and then deletes it from the queue.
            The failure messages are saved to an azure table name “Messages”. This table is partitioned by hostname and then time. This choice was made so we can easily identify all errors generated by a specific instance of a receiver, in the order in which they occurred. It is unlikely that the same receiver will have multiple error in same millisecond which makes the partition key, row key combination, hostname and time unique.
        </p>
    </div>
    <div class="container">
        <h2>Receiver</h2>
        <h3>Implementation</h3>
        <p>
            The receiver was implemented as a simple node js application which polls the service bus queue for messages. If the queue is empty, no work is done. If the queue is not empty a message is returned. If the message simulates a error, it logged by appending to the an azure table. Otherwise it is processed by incrementing the messages received counter. For more complicated processing logic, the receiver should determine if this message was already processed since the receiver uses a two stage approach to process messages. It is possible for a receiver to  receiver and and process a message (stage one), and fail before deleting the messages from the queue (stage two). In this case, the message will remain on the queue and be processed again by a receiver.
        </p>
        <h3>Scale</h3>
        <p>
            Each receiver runs on Ubuntu 16.04 LTS in an A1 virtual machine (1 core, 1.75 GB RAM, 500 IOPS). A virtual machine scale set (VMSS) was used to scale out the receivers so it can handle the required load. If the length of the service bus queue exceeds a threshold t1, this means the receivers are not processing messages fast enough and may not compete the required amount of transactions to honour the the service layer agreement of 300 000 transactions in one hour. Additionally, if the VMSS average CPU utilization is greater than T1 over five minute interval, this indicates that the load on the vmss is increasing and it should scale out before average CPU utilization peaks and the application becomes unresponsive.
            Similarly if the if the length of the service bus queue is under a threshold t2, the receivers will be able to process the transactions and achieve the service layer agreement of 300 000 transactions in one hour. Also, if the VMSS average CPU utilization is less than T2 over five minutes, this indicates load on the vmss is decreasing. In either case, the VMSS will have more receivers than so it scale in.
            The specific values of t1, T1, t2, and T2 will have to be determined empirically to meet the needs of the specific application. From our testing,we found that t1 = 500  ,T1 = 60, t2 = 100, and T2 = 20 work best for the requirements of this assignment.
        </p>

    </div>
    <div class="container" ng-init="retrieve()">

        <h2>Sender Monitor {{count}}</h2>
        <div class=" well col-sm-12">
            <div>
                <form class="form-inline">
                    <div class="form-group">
                        <label for="exampleInputName">Name</label>
                        <input type="text" class="form-control" id="exampleInputName" placeholder="host:port" ng-model="newurl">
                    </div>
                    <button type="submit" class="btn btn-default" ng-click="addNew()">Add Server</button>
                </form>
            </div>

            <br>
            <div ng-repeat="vm in vms track by $index" class="panel panel-default">
                <div class="panel-body">
                    <div class="col ">URL {{vm.url}}</div>
                    <div class="col">Status {{vm.status}}</div>
                    <div class="col">Request Count {{vm.count}}</div>
                    <div class="col">Time {{vm.time}}</div>
                </div>
            </div>
        </div>
        <div>
            <div class="btn-group btn-group-justified" role="group" aria-label="...">
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-success" ng-click="start()">Start</button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-primary" ng-click="refresh()">Refresh</button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-danger" ng-click="stop()">Stop</button>
                </div>
            </div>
        </div>
    </div>
</div>



<script src="angular.min.js"></script><!-- load angular -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script>
	var app = angular.module('app', []);

	app.controller('mainController', function($scope, $http){

		var get = function(url, route, callback){
			$http.get(url+route)
				.then(callback);
        };

		$scope.newurl ="http://";

		$scope.count = 0;

		$scope.vms = [
			{
				url:"http://snickdx.me:8080",
				count:0,
				status:'idle',
				time:""
			}

        ];

        $scope.retrieve = function(){
        	var urlStore = localStorage.getItem("urls");

        	if(urlStore){
		        $scope.vms= [];
        		JSON.parse(urlStore).forEach(function(item){
			        $scope.vms.push(item);
		        });
            }

        };

		$scope.addNew = function(){
			$scope.vms.push({
				url:$scope.newurl,
				count:0,
				status:'idle',
				time:""
			});

			if (typeof(Storage) !== "undefined") {
				localStorage.setItem("urls", JSON.stringify($scope.vms));
			} else {
				console.log("Sorry, your browser does not support Web Storage...");
			}

			$scope.newurl = "http//";
        };

		$scope.refresh = function(){
			$scope.vms.map(function(vm){
				get(vm.url, "/getCount", function(response){
					vm.count=response.data.count;
					vm.time=response.data.time;
					$scope.count+=response.data.count;
				});
			})
        };


		$scope.start = function(){
			$scope.vms.map(function(vm){
				get(vm.url, "/start", function(response){
					vm.status=response.data;
                });
            })
        };

		$scope.stop = function(){
			$scope.vms.map(function(vm){
				get(vm.url, "/stop", function(response){
					vm.status=response.data;
				});
			})
        };



	});

</script>
</body>
</html>